# 实验报告一

### PB16050567	陈炜

## Part1——A*搜索问题

### 1、A*搜索

##### 一、算法概述

​	A*是一种启发式搜索方法，根据全局信息得到每一个节点的启发函数值h(n)，根据启发函数值h(n)和当前已经消耗的代价g(n)得到估计代价f(n)。根据f(n)对节点排序，一直向代价最低的节点的方向前进，直到抵达终点。

##### 二、实现概述

​	A\*搜索要求每次访问节点队列中f(n)值最小的点，这和优先队列不谋而合。我们可以将正在探索的节点放在一个优先队列中，每次寻找下一个要访问的节点的时候，就访问优先队列中f(n)值最小的节点即可。

​	A\*算法其实是类似一个BFS的搜索过程，从头到尾维护一个优先队列。在搜索开始的时候，将起点加入优先队列中，然后开始以下循环：

1、从优先队列中取的f(n)最小的节点。

2、将被取出节点标记为不能再被访问的节点。

3、访问被取出节点四周的四个节点(边界以内)，如果被访问的节点已经是不能被访问的，无操作； 	如果被访问的节点在优先队列中，就判断新的f(n)的值是否小于被访问节点持有的f(n)，如果是，更新被访问节点的f(n)值，否则无操作；	 如果被访问节点是从来没有被访问过的，算出他的f(n)值，加入优先队列。

​	直到把终点从优先队列中取出，说明找到了最短路径。

​	如果循环到栈为空都无法抵达终点，说明终点不可达。

##### 三、数据结构：

1、节点的数据结构：每个节点存储他自己的行列值，G值，H值和F值(初始化为一个极大的值)，以及Parent，指明他的父亲节点，也就是在A*寻得的路径中的上一个节点。

```C++
struct Node			//A*中的节点定义
{
	int row, col;
	int G;
	int H;
	int F = MAXF;
	Node* Parent = NULL;	//A*中路径上的上一个节点
};
```

2、一个优先队列，存放正在被访问的节点，该优先队列的成员包括：

vec:存放堆中的所有节点的数组。

count:堆中的节点数量。

Empty():判断堆是否为空。

Search:根据行、列的值在堆中进行搜索，返回指定节点在堆中的下标。

GetNode：根据输入的下标值，返回堆中节点的指针。

Min_Heapfy:维持小根堆结构。

ExtractMin：返回f(n)值最小的节点。

Decrease:更新堆中节点的f(n)值。

Insert:插入新节点。

```C++
class MinHeap
{
private:
	Node* vec[SumNode];				//存放堆中节点的数组
	int count;						//当前堆中的总的元素数量
public:
	MinHeap()
	{
		memset(vec, 0, sizeof(Node*)*SumNode);
		count = 0;
	}
	~MinHeap()
	{
		for (int i = 0; i < count; i++)
			delete vec[i];
	}
	bool Empty()
	Node* GetNode(int i)
	void Min_HeapFY(int i)	
	Node* ExtractMin()
	int Serch(int r, int c)			//返回vec中的编号
	void Decrease(int i, int NewG)		//因为堆的结构和x,y无关，i是数组下标
	void Insert(Node* n)
	
};
```

3、一个地形地图和一个状态地图：

```C++
int **Map;
int **Status;
```

​	其中，状态地图Status上的每个点的取值可以是以下三种：

```C++
enum Flag
{
	Untouched,		//从来没有遇到过的节点
	OPEN,			//队列中
	Closed			//已经close掉的
};
```

​	使用这样一个地图的主要考虑是：

​	当我取出优先队列中的f值最小节点并访问他周围的四个节点的时候，我需要知道这四个节点分别处于哪一个状态。

​	一种选择是：另外建立一个数组来存储已经被取出过，不能再访问的节点，每一次判断节点状态的时候就遍历这个数组和优先队列来判断。

​	但是考虑到判断状态的操作是A*算法中最频繁的操作，并且一个30\*60的二维int型数组的额外空间开销也并不是特别大。所以就使用这样一个状态地图来保存节点的状态信息。这个时候，在我访问节点的时候，就可以直接根据状态地图来判断当前节点的状态来确定我需要进行的操作了。

###### 启发式函数的选择：

​	启发式函数首先要满足可采纳性和一致性，其次，要能较好地估计从当前节点到目标节点所需要的代价。

​	在本问题的迷宫中，我们只能往上下左右四个方向走，这和曼哈顿距离不谋而合，曼哈顿距离可以最好地本问题中估计从一个点到终点所需要的最少的代价。

​	而诸如欧式距离等其他的启发函数，都不如曼哈顿距离在本问题中合适，因为我们不能在迷宫中斜着走。

##### 四、具体实现与核心代码：

​	寻路的主循环：一直循环直到寻路栈为空(能走到的所有节点都走到了，仍然没有到达终点)，或者抵达了终点。

```C++
while (!ASheap->Empty())		//寻路的栈不为空
	{
		Current = ASheap->ExtractMin();
		if ((Current->row == EndNode->row) && (Current->col == EndNode->col))
		{
			EndNode = Current;
			find = true;
			break;
		}
		Handle(ASheap, Current, Current->row - 1, Current->col);
		Handle(ASheap, Current, Current->row + 1, Current->col);
		Handle(ASheap, Current, Current->row, Current->col - 1);
		Handle(ASheap, Current, Current->row, Current->col + 1);
	}
```

​	处理被访问节点的函数：Handle:

​	碰到新点就创建新节点，碰到队列中的节点，就比较f值，尝试更新。

```C++
if (Pass(r, c))		//可通行
	{
		if (Status[r][c] == Untouched)		//新节点
		{
			Node* NewNode = new Node;
			NewNode->row = r;
			NewNode->col = c;
			NewNode->G = P->G + 1;
			NewNode->H = abs(endr - r) + abs(endc - c);
			NewNode->F = NewNode->G + NewNode->H;
			NewNode->Parent = P;
			heap->Insert(NewNode);
		}
		else if (Status[r][c] == OPEN)				//已经在队列中的节点,看是否需要更新
		{
			int i;
			i = heap->Serch(r, c);
			Node* C = heap->GetNode(i);
			if (C->G > P->G + 1)
			{
				heap->Decrease(i, P->G + 1);
				C->Parent = P;
			}
		}
		return;
	}
```

更新队列中节点的f(n)值：

```C++
void Decrease(int i, int NewG)		//因为堆的结构和x,y无关，i是数组下标
	{
		vec[i]->G = NewG;
		vec[i]->F = NewG + vec[i]->H;
		int a = i;
		int p = (a - 1) / 2;
		while (a > 0 && vec[p]->F > vec[a]->F)
		{
			Node* temp;
			temp = vec[a];
			vec[a] = vec[p];
			vec[p] = temp;
			a = p;
			p = (a - 1) / 2;
		}
	}
```

寻找路径：

```C++
while (p->Parent != NULL)
		{
			if (p->row == pre->row)		//行相等，处理列不同的情况,L或者R
			{
				if (p->col < pre->col)		//向左走
					path.push_back('L');
				else
					path.push_back('R');
			}
			else
			{
				if (p->row > pre->row)		//向下走
					path.push_back('D');
				else
					path.push_back('U');
			}
			++step;
			p = pre;
			pre = pre->Parent;
		}
```

##### 五、运行结果：

![img](file:///C:\Users\陈炜\AppData\Roaming\Tencent\Users\865724378\QQ\WinTemp\RichOle\47U7SUG8VHYI@CH{8OY1Y$Q.png)

input1:

![img](file:///C:\Users\陈炜\AppData\Roaming\Tencent\Users\865724378\QQ\WinTemp\RichOle\Q%2W6G}UXIY4JZJIG2Z6L}N.png)

input2:

​	![1557636756244](C:\Users\陈炜\AppData\Roaming\Typora\typora-user-images\1557636756244.png)

​	经过手动检验，验证了两个结果都是正确的，并且是最短路径。

##### 六、算法分析：

###### 时间复杂度：

​	A*搜索的复杂度与起点到终点的最短路径长度有关。在本问题中，我们选择了完全合适的评估函数，曼哈顿距离，A\*算法在实行的过程中基本不会向绕路的方向前进，是和最短路径长度L有关的函数。

###### 空间复杂度：

​	在这次A*搜索中，空间复杂度 主要来自记录已经保存的节点以及一个额外的状态地图。状态地图占据空间为m\*n地图大小的int型变量大小。而每个节点占据的空间是：5个int型+一个指针型变量。

​	节点总数和最短路径长度有关，在本问题中，每一次都扩展一个节点四个方向上的邻近节点，所以大约会产生4L个节点。

​	本问题中的最短路径只有116步，所以空间复杂度比较小。

### 2、IDA*搜索：

##### 一、算法概述：

​	和A*使用队列的，类似广度优先搜索的方式不同，IDA\*使用的方式是迭代加深的深度优先搜索+剪枝。

​	将初始节点的f(n)值设为maxf，然后开始深度优先遍历，对f(n)值大于maxf的节点都不访问。如果一次深度优先遍历没有找到终点，将maxf设为上一次遍历中遇到的大于maxf中的f(n)的最小值，再次进行深度优先遍历，直到找到终点。

##### 二、实现概述：

​	IDA*的实现比较简单，不需要什么特别的数据结构。只需要在地图上进行深度优先遍历，访问一个节点的时候，在地图上把当前节点的值设为2（和空位与墙区别开来）表示路径经过这里，在递归退出该节点的访问的时候，把这个点的值重新设为0。这样做的好处有：1、保证不会走到路径上存在的点。2、完成搜索以后，可以根据这个信息得到路径信息。 

​	但是在实际操作中，IDA*只在第一个非常小的地图上得到满意的结果，在第二个地图上表现会非常差，因为深度优先搜索的时间复杂度本就是随着路径长度指数级增长的。我在一次实验中在中午启动了IDA\*搜索之后去上课，四个小时上课回来以后仍然没有得出结果，这显然是不可接受的。

​	我认为IDA*在input2的基础上难以时间复杂度巨大甚至无法得出结果的主要原因不仅是路径长度的增加，更是由于Input2的地图过于稠密。绝大部分节点的分支都是4，都是互联互通的。IDA\*搜索的主要时间都会花费在房间中的无意义转圈中。

​	为了解决这个问题，只能额外付出一些空间代价来记录一定的信息。

​	我的做法是，使用一个和原地图一样大的二维数组来记录本次深度优先遍历中已知的最小f(n)的信息。

​	1、在每一次深度优先遍历之前，把这个二维数组的每一个元素的值都设为极大值。

​	2、在深度优先遍历的过程中，访问一个地图上的点之前，考虑从这一步走过去产生的f(n)的值是否比这个点当前的f(n)的值要小，如果确实更小，那么访问这个节点，并且更新这个节点的最小f(n)值。否则不访问这个节点，因为从这一步走过去是一定不可能找到终点的。

​	经过这个修改以后，IDA*就能在可以接受的时间内完成搜索了。

##### 三、数据结构：

​	IDA*中主要的数据结构就是两个地图，一个是原有的地图，一个是记录f(n)值的地图，每一个地图都是一个二维数组。

##### 四、具体实现和核心代码：

1、迭代加深循环主体：

每一次失败的深度优先遍历以后就将maxf设为newf，继续遍历。

```C++
	int maxf = H[beginr][beginc];
	newf = 65535;
	while (!found && maxf < limitF)		//
	{
		for (int i = 0; i < rmax; i++)
		{
			for (int j = 0; j < cmax; j++)
				Status[i][j] = 65535;
		}
		found = DFS(maxf, beginr, beginc, 0);
		if (found)
			break;
		maxf = newf;
		newf = 65535;
	}
```

2、DFS深度递归函数：

如下，对四个方向递归，直到找到终点即可。

```C++
int plusr[4] = { 0,1,0,-1 };
int plusc[4] = { 1,0,-1,0 };
bool DFS(int maxf, int r, int c, int g)
{
	if (r == endr && c == endc)
	{
		Map[r][c] = 2;
		return true;
	}
	int f = H[r][c] + g;
	if (f > maxf)
	{
		if (f < newf)
			newf = f;
		return false;
	}
	Map[r][c] = 2;
	Status[r][c] = f;
	bool found = false;
	int newr;
	int newc;
	for (int i = 0; i < 4; i++)
	{
		newr = r + plusr[i];
		newc = c + plusc[i];
		if ((g + 1 + H[r][c]) > Status[newr][newc] || Map[newr][newc] != 0 || newc < 0 || newc>59)
			continue;
		found = DFS(maxf, newr, newc, g + 1);
		if (found)
			break;
	}
	if (!found)
		Map[r][c] = 0;
	return found;
}
```

3、还原路径：

```C++
string path;
	int next;
	for (int i = 0; i < maxf; i++)
	{
		next = ToFindPath(fr, fc);
		switch (next)
		{
		case 0: {path.push_back('R'); break; }
		case 1: {path.push_back('D'); break; }
		case 2: {path.push_back('L'); break; }
		case 3: {path.push_back('U'); break; }
		default:
			{
				printf("error");
				break;
			}
		}
		Map[fr][fc] = 0;
		fr = fr + plusr[next];
		fc = fc + plusc[next];
	}
```



##### 五、运行结果

![1557663259480](C:\Users\陈炜\AppData\Roaming\Typora\typora-user-images\1557663259480.png)

input1:

![img](file:///C:\Users\陈炜\AppData\Roaming\Tencent\Users\865724378\QQ\WinTemp\RichOle\J8@92HZ[BB[[OA$RKH$E7K9.png)

input2:

![1557647641700](C:\Users\陈炜\AppData\Roaming\Typora\typora-user-images\1557647641700.png)

​	同样经过手动检验，两个结果都是正确的。

##### 六、算法分析：

##### 时间复杂度：

​	原本的IDA*的时间复杂度应该是O(b^m)的，经过修改以后，增加了空间复杂度，但是时间复杂度变得在大部分情况下与地图中的空位点数量相关，除非每一次深度优先遍历都遇到了，每一条后遍历的路径都比之前遍历过的路径的f值小的极端情况。也就是说在最坏情况下仍然是O(b^m)次方的。

##### 空间复杂度：

​	原本IDA*的空间复杂度应该就是地图的大小：m\*n的，在经过这样的修改以后，变成了2\*m\*n，两个地图的大小，还是可以接受的。









## Part2——五子棋人机对弈

### 一、评分函数：

#### 1、概述和分值设计：

​	在这次的五子棋实验中，我认为最重要的就是评分函数的设计了。

##### 	五子棋棋型：

​	长连：五子连珠，胜利。

​	活四：有两个连五点，如011110.

​	冲4：只有一个连五点，如211110或者10111等。

​	活3：可以形成活4的三，比如011100.

​	眠3：只能形成冲4的三。比如010101.

​	活2：可以形成活3的2.

​	眠2：只能形成眠3的2.

##### 	对上述棋型的分析如下：

​	（1）在无禁手的五子棋中，胜利的棋型是长连，当然应该得到最高的分。

​	（2）在长连之下：决胜的棋型是活4，双冲4，冲4活三。这些棋型都是无法进行防守的，应该得到很高的分数。双活三在大多数情况下也是无法防住的，但是仍然会有极端的情况：如果你持有双活三，而对手持有冲4，那么主动权在对方手上，如果不封堵冲4，则对方胜利。如果对手持有多个冲4，就可能在你丧失主动权的这个阶段中将你的活3变成眠3(只能形成冲4的3)甚至死3。但是大多数情况下，双活三还是必胜的，我们可以暂且不考虑极端的情况。

​		上述棋型都应该有一个很高的分，比下述棋型有数量级上的差距。

​	（3）冲4和活3：冲4和活3都是在对方没有冲4和活3以上的棋型的时候必须选择防守的棋，是可以掌握主动的棋型。但是冲4离胜利只差一步，活3差两步，两者的评分应该有差距，但是不能差一个数量级以上。

​	（4）眠3和活2：和第3个情况类似的，眠3应比活2分高。

​	（5）眠2和活1：这两个应该是除了死棋和被一端被堵住的1以外的分最低的情况。

##### 	评分规则分析：

​	我认为上述棋型中，不同阶级的棋型的分数应该有数量级上的差距，统一阶层的分数视情况有一定的不同。算出玩家和AI的分数以后，相减得到局面的分数。

​	但是长连例外，长连不应该使用两者的分数相减，因为场面上如果有两个长连，必然是有先后顺序的，一方先达成长连，游戏就宣告结束了，评分应该是极大值或者极小值，而不可能是0。	

#### 2、棋型判断方法：

##### 	棋型判断思路：

​	我认为在评分中很关键的点是，对冲4和活三以上的棋型，要准确地估计，一定不能高估或者低估冲4和活3以上棋型的数量，因为这以上的棋型都是必须防守甚至决胜的无法防守的棋型，权重都很大。而诸如眠2眠3之类的棋型，重要性和活3以上的棋型都有鸿沟大的差距。

​	基于这样的想法，我评分的思路是：对每一个点进行扫描，取从这个点延申出去的右、下、右上、右下四个方向的五个子，加上反方向的一个子一共六个子进行判断。

##### 	具体判断流程：

​	首先，只对存在我方棋子的位置进行扫描判断，对空位和对方棋子予以忽略。

​	以AI棋子的一个方向的棋型判断为例：

###### 	1、提取信息：提取延申方向的五个位置和反方向的一个位置的信息：

​	（1）h表示该我方棋子的左边有没有被堵住，如果左边为空，那么表示没有被堵住，如果是我方棋子或者敌方棋子，那么就是被堵住了。

​	在这里，将我方棋子也作为挡住的障碍的主要考虑是：减少扫描中对一个棋型的重复扫描带来的高估，举个例子：棋型：011100，第一个1进行判断后会得到一个活3，那么这个活3的分数就应该是这三个子的总分数了，剩下两个点不应该计分，但是这样的判断是困难的。所以我还会对第二个1进行扫描，把第二个子的分数视为眠2就比视为活2带来的高估的误差要小得多。如果视为活2，那么总分是110的话，视为眠2的总分就是101，百分之1的误差我认为是可以接受的。

​	（2）pos表示敌方棋子(如果有的话)在延伸出去取得的五个棋子中的位置。

​	（3）conti表示当前正在扫描一个连续的段：如果扫描到敌方棋子了，conti就应该置为false，因为被敌方棋子中断以后的点对当前点都是无意义的。

​	  （4)a就是提取出来的数组，表示这五个点的情况。

```C++
//横向
			if (j + 4 < 15)
			{
				h = false;
				pos = 0;
				conti = true;
				linecount = 0;
				if (j - 1 < 0 || Map[i][j - 1] != 0)		//左边被堵上了
					h = true;
				for (int k = 0; k < 5; k++)
				{
					a[k] = Map[i][j + k];
					if (a[k] == 1 && conti)
						linecount++;
					if (a[k] == 2)
					{
						conti = false;
						pos = k;
					}

				}
				if (linecount == 5)
				{
					Awin = true;
					break;
				}
				temp= EachScore(h, a, linecount, conti, pos, 1);
				if (temp >= 1000)
					AHcount ++ ;
				As += temp;
			}
```

###### 	2、利用信息进行判断：

​	以下谈到的连续子，不是指形如1111这样只有我方棋子的连续段，而是没有敌方棋子阻隔的我方棋子的数量，比如说101就是两个连续子，121就是一个。

​	一、反方向被堵住的情况：

```C++
if (!conti)				//5步以内被堵住，没有可能性了
			return 0;
		switch (line)		//5步以内没有被堵住
		{
		case 1:
			return 1;
		case 2:					//只有中间最多空一个的情况是眠2，隔得太远则无意义
		{
			if (a[1] == player || a[2] == player)
				return 5;
			else
				return 1;
		}
		case 3:
		{
			if (a[4] == player)			//如果3个中有一个在最后一格，那么无论如何都是眠2而不是眠3，下面的活三同理
				return 5;
			else
				return 200;
		}
		case 4:							//无论如何都是冲4
			return 2000;
		}
```

​	1、如果反向被堵住了，并且延申出去的5步以内有对方的棋子，那么这一段内无论怎么下，都是死棋，没有分。

​	2、如果连珠的子只有一个：就是眠1。

​	3、如果连续的子有两个，需要进行判断:如果是211000或者210100的情况，是可以形成眠3的，如果两个一之间距离太远，就没有意义了。比如210010这样的情况，左边的第一个1就是可以抛弃掉的一个眠1.

​	4、连续的子有三个：如果是三个子没有一个在第五格的位置，那么无论如何都是可以冲4的，否则不行。枚举如下：棋型是210011或者210101或者211001是不能型成的。	而211100，211010，210110是可以的。

​	5、连续的子有4个：那么无论如何都是冲4了。



​	二、反方向没有被堵住的情况：

​	1、正向5步范围内被堵住：

```C++
if (!conti)			//五步以内被堵住了
		{
			switch (line)
			{
			case 1:
				return 1;
			case 2:
			{
				switch (pos)
				{
				case 2:
					return 5;	//眠2
				case 3:
					if (a[2] == player)
						return 5;		//眠2
					else
						return 100;		//活2
				case 4:
					if (a[3] == player)
						return 5;
					else
						return 100;
				default:
					return 0;
				}
			}
			case 3:
				switch (pos)
				{
				case 3:
					return 200;		//眠3
				case 4:
					if (a[3] == player)
						return 200;
					else
						return 1000;
				default:
					return 0;
				}
			case 4:
				return 2000;		//连续冲4
			default:
				return 0;
			}
		}
```

​	(1)连续子只有一，必定是眠1

​	(2)有两个连续子：要考虑对方的棋子在哪个位置堵住了。基本想法是，如果对方的棋子紧邻我方的另一个棋子，那么是眠2，否则就是活2。

​	(3)有三个连续子：同样考虑我方的最右边的棋子是否和敌方棋子紧邻，如果是，那就是眠3，否则是活3。可以这样判断的主要原因是，这三个连续子一定分布在紧邻第一个子的四格之内，不会出现在第五格。否则就不会进这个if语句了。

​	(4)有四个选择子：必然是冲4.



​	2、正向五步范围内也没有被堵住的情况：

```C++
switch (line)		//范围内没有被堵住
		{
		case 1:
			return 10;
		case 2:
			if (a[1] == player || a[2] == player)		//活2
				return 100;
			else							//距离太远，忽略
				return 5;
		case 3:
			if (a[4] == player)				//眠3
				return 200;
			else						//活3
				return 1000;
		case 4:
			if (a[4] == player)
				return 2000;
			else
				return 100000;
		}
```

​	判断思想大致和上面是相同的。只要判断连续子的最后一个和第一个的距离是否超出范围即可，超出了就是眠，没超出就是活。比如010011就不是活三，而010110是活3.

​	

​	在评估一个棋盘的分数的时候，我们就以上面的方式遍历我方棋子向4个方向延申就行了，不需要8个方向，因为对我方所有棋子都遍历，所以是不会遗漏的。

​	在此评分之外，我还引入了一个计数器来计算活三以上的棋型数量，如果有两个以上，就置为活4的分数。

​	在没有长连的情况下，就以上述方式对双方进行评分，然后用我方的分数减去敌方的分数即可。

​	

##### 	长连的判断：

​	在长连的判断中有一个麻烦的地方，出现敌我双方都是长连的情况在实际中是不存在的，在这种情况下，绝对不可能返回0分，但是我们知道在博弈树里面，双方都至少各自下了两步棋，单单根据棋型是无法判断到底是谁获得了胜利的。

​	为了解决这个问题，我的想法是，控制棋盘让他不会出现两个长连的情况。

​	具体做法是：在每一层的每一个节点，都单独进行一次是否达到自己的长连的判断，如果达到长连，则直接返回长连的分。这也是不违反α-β剪枝的规则的。因为，如果轮到极大值落子时，如果发现下了这一步就达到了长连，那么这一步一定是极大值，后续的点不管怎么下都不可能比这一步得到的分数更高了。所以就直接剪枝即可，极小值同理。

​	这个做法增加的时间复杂度也是有限的，因为博弈树中每一层的节点都大致是上一层的1/n。

​	在这样的情况下，长连的判断就容易多了，因为不会出现双方都长连的情况，所以就直接分别判断是否有一方达到长连即可,如果达到长连，就直接返回极大值或者极小值

​	代码的这个部分如下：

```C++
				if (linecount == 5)
				{
					Awin = true;
					break;
				}
				......
                ......
                 if (linecount == 5)
				{
					Pwin = true;
					break;
				}
```

```C++
		if (Pwin)
		{
			return -1000000;		//6个0
		}
		if (Awin)
		{
			return 1000000;		//6个0
		}
```



### 二、算法思想和α-β剪枝：

​	本问题主要采用极大极小算法构造博弈树进行分析。

##### 	极大极小算法：

​	假设两个游戏者，AI和玩家都用最佳策略行棋，所以AI在所有可能的行棋选择中选择使效用值达到最高的，假设玩家会在所有可能的行棋选择中选择使AI的效用值达到最低的，按这样的方式对所有可能的行棋选择做深度优先遍历，每一层会把他的极小极大值回传，一直到根节点。我们的根节点是一个Max节点，选择所有选择中使效用值达到最高的方式即可。

##### 	α-β剪枝：

​	α-β剪枝会剪掉对决策没有影响的分支，从而提高算法的效率。

​	对Min节点来说，如果一个Min节点发现它的一个分支得到的效用值比之前已知的Min节点的最大效用值要小，它就可以推断出，这个Min节点选出的Min值一定比之前已知的Min值要小，它上层的Max节点一定不会选择这个Min节点，那么这个Min节点就不用再继续搜索下去了。对Max节点也是同样的道理。

​	在本次实验中，我们的Max节点会在循环中更新极小极大值并传递给后续的所有Min节点，如果一个Min节点发现自己向下递归得到的当前Min值比这个值更小，那么就可以剪枝了。Min节点的循环也会做相同的事情。

​	部分代码如下：

Max节点：

```C++
			tempscore = BetaTree(maxlength, depth , MaxScore);
			if (tempscore > MaxScore)
			{
				MaxScore = tempscore;
				Pickr = i;
				Pickc = j;
			}
			Map[i][j] = 0;
			LimitRollBack(lold, rold, uold, dold);
			if (MaxScore > MinBefore)
			{
				cut = true;
				break;
			}
		}
		if (cut)
			break;
```

Min节点:

```c++
tempscore = AlphaTree(maxlength, depth+1, MinScore,NULL);
			if (tempscore < MinScore)
			{
				MinScore = tempscore;
				Pickr = i;
				Pickc = j;
			}
			Map[i][j] = 0;
			LimitRollBack(lold, rold, uold, dold);
			if (MinScore < MaxBefore)
			{
				cut = true;
				break;
			}
		}
		if (cut)
			break;
```



### 三、实验结果：

​	因为我的下棋水平实在是有限，所以几乎都输给了AI。

​	手边也没有现成的棋力评估的工具，于是就用AI在线和人对弈。在先手的情况下，大部分时候都是能赢的，所以我认为这个AI的棋力在爱好者中算是能达到中游的水平。

​	某次实验的结果如下：AI完成了一次双冲4，并且把握住了机会获得了胜利。(+为AI，*为玩家)

​	![1557659340135](C:\Users\陈炜\AppData\Roaming\Typora\typora-user-images\1557659340135.png)

​	对弈的流程如下：

​	![1557659471036](C:\Users\陈炜\AppData\Roaming\Typora\typora-user-images\1557659471036.png)

​	

​	我在和AI对弈的过程中得到了不小的提升，获得了一些下五子棋的感悟。

​	1、不要沉迷于连续的棋型的构造，我以前下五子棋，最喜欢的就是下出01110的活三。和AI对弈的过程中，我发现这种想法不行，有的时候眠三甚至比活三更好，更多的还是要兼顾整个棋盘各个方向的局面

​	2、不要盲目冲4，冲4也不一定要走连续的冲4，冲4作为杀招，是掌握主动权的方式，应该作为一种资源保留，不要有冲4就去冲，这样只会把冲4的意义最小化。

​	3、总体来说，最大的收获还是，要多想几步，多考虑整体的局势，不要太在意一个点的得失。

### 四、思考题：

##### 1）决策深度对AI的各个方面都有重大的影响，

​	最直接的：决策深度越深，AI能考虑的情况越多，用人类的话讲就是能看得越远，想得越多。	

​	其二，在上文中我提到，对长连的判断，是每一层都要进行的，这样才能避免出现两个长连不知所措的情况。但是我在实际的对弈过程中发现了一个问题。在活4的情况下，也就是AI拥有两个连5点，它会开始”戏弄“玩家，故意不去下连5点，而是随便找个地方就下了。而当AI必败的时候，AI就会放弃挣扎，随便找个点就下了。

​	对程序进行分析以后我发现，问题的关键在于，不管是通过走两步获得胜利还是走一步获得胜利，对AI来说都是一样的，分数不会因为深度而有所改变，这就会导致AI认为这两种情况是完全一样的，所以能一步赢的棋，它会去走两步，失败的时候同理，反正要输了，下哪里都是输，那就放弃挣扎吧。

​	但是这样的情况是不符合我们对他的要求的，人类的想法是，如果一步能赢，那我就一步赢，不要拖泥带水，即使要输了，也要努力挣扎一下，万一重现生机(对方没看到)呢？

​	我的方法是，对搜索深度加一个权重，同样是达到长连获得胜利，深度越深，得分越低。我的权重值暂定为0.05，也就是说，递归返回的值是MaxScore*(1-0.05\*depth)。Min节点同理，这样一来，对AI来说，在近层达到胜利的”诱惑力“就比多走很多步达到胜利的大。AI就会优先选择在近层直接获得胜利。对注定失败的情况而言，在深层次（多走几步）失败也比直接在近层失败来得更好一点，所以AI就会选择挣扎一下。



##### 2）改进剪枝策略：

​	我觉得我对长连的处理方式就是改进剪枝策略的一个雏形，我们可以对空位点来进行评分，评分的依据就是在这个点下子自己能多得得分数和对方会少得的分数的总和，也就是进攻分和防守分的总和，来进行评分。

​	我在实验的初期试着使用了这样一个评估值来进行启发式的搜索，但是发现时间复杂度反而大大提升了。原因在于，其一，在每一个节点对棋盘做一次简单的评分变成了对所有节点下棋以后，得到的分进行评价，复杂度增加了n倍，更难以接受的是要对各个点进行排序，排序的复杂度是n\*longn的。所以这个启发式函数是不行的。

​	后来尝试如下思路：维护两个存储启发值的棋盘，一个存储玩家的启发函数值，一个存储AI的启发函数值。每下一个子，就去更新关于以这个棋子为中心的米字形的行列上距离5以内的棋子的启发函数值。而每一个点的启发函数的值不是由8个方向的左右两边的距离为5以内的棋子和这个点如果下下去所得到的棋型决定。

​	但是结果仍然不是特别好，我认为还是排序对时间复杂度的影响有点大。

​	但是我觉得还有另一个剪枝的思路：对一个五子棋局面来说，到达这个局面的顺序是不重要的。所以我们也许可以对棋盘的局面做一个hash值，如果碰到了重复的局势，就没有继续往下搜索的必要了，可以直接拿到这个值，而且这个方法不仅能在一次对弈中使用，如果我们将它存储起来，那么在下一次的对弈中同样也可以使用，随之对弈局数的增加，这个五子棋AI的反应速度将会越来越快。



##### 3）实现自学习能力，让AI不在同样的地方犯错：

​	我们在每一次的实验结果中记录了对弈的过程，这是一个非常有用的信息。

​	如果AI输掉了这一局，他可以反向复现这一次对弈的过程，首先将所有棋子下下去，然后根据对弈的过程，倒着把棋子一个个拿掉并评估，直到到达评估函数不是必败的局面为止。在这一层，就换一种方式来下，看看自己搜索能不能得到非必败的结果，如果可以，把这种选择保留下来，下一次对弈中就使用这次的结果来下棋。如果还是输，就再换一种，如果这一层都走完了还是输，就返回上一层继续搜索，直到胜利为止。这样的过程会让这个五子棋AI的智能程度随着对弈局数的增加而增强。

​	